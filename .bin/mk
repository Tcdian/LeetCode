#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const _ = require('lodash');

main();

async function main() {
    const directory = await getDirectory('leetcode');
    render(directory);
}

async function getDirectory(fileOrDirPath) {
    const absolutePath = path.resolve('.', fileOrDirPath);
    const relativePath = path.relative('.', fileOrDirPath);
    const name = fileOrDirPath.match(/([^\/]+?)(\.(js|ts)\.md){0,1}$/i)[1];
    const stat = await fs.promises.stat(absolutePath);
    if (stat.isFile()) {
        return { type: 'file', name: name, path: relativePath };
    }
    const dirs = await fs.promises.readdir(absolutePath);
    const files = await Promise.all(_.map(dirs, (dir) => getDirectory(path.join(fileOrDirPath, dir))));
    return { type: 'directory', name: name, path: relativePath, child: files };
}

const topics = [
    '链表',
    '栈与队列',
    '哈希',
    '数组',
    '二分查找',
    '排序',
    '双指针',
    '滑动窗口',
    '二叉树',
    '回溯',
    '贪心',
    '动态规划',
    '并查集',
    '字典树',
    '线段树',
    '深度优先搜索',
    '广度优先搜索',
    '拓扑排序',
    '前缀和',
    '设计',
];

async function render(directory) {
    await fs.promises.writeFile('./README.md', `${renderDirectory(directory)}`);

    function renderDirectory(fileOrDir, level = '###') {
        if (fileOrDir.type === 'file') {
            return `-   [${fileOrDir.name}](<${fileOrDir.path}>) \n`;
        } else if (fileOrDir.type === 'directory') {
            return `${level} ${fileOrDir.name}
    
${fileOrDir.child
    .sort((a, b) => topics.indexOf(a.name) - topics.indexOf(b.name))
    .map((item) => renderDirectory(item, level + '#'))
    .join('')}
`;
        }
    }
}
