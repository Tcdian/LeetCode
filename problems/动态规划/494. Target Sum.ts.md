## 494. 目标和

[<img src="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg" height="20" /> https://leetcode-cn.com/problems/target-sum/](https://leetcode-cn.com/problems/target-sum/)

[<img src="https://assets.leetcode.com/static_assets/public/webpack_bundles/images/logo-dark.e99485d9b.svg" height="20"/> https://leetcode.com/problems/target-sum/](https://leetcode.com/problems/target-sum/)

###

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加  `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。
返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

#### 示例 1：

```
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

#### 示例 2：

```
输入：nums = [1], target = 1
输出：1
```

#### 提示：

-   `1 <= nums.length <= 20`
-   `0 <= nums[i] <= 1000`
-   `0 <= sum(nums[i]) <= 1000`
-   `-1000 <= target <= 1000`

#

#### 方法：动态规划

```ts
function findTargetSumWays(nums: number[], target: number): number {
    const sum = nums.reduce((sum, current) => sum + current);
    if ((sum + target) % 2 === 1 || sum + target < 0) {
        return 0;
    }
    const capacity = (sum + target) >> 1;
    const dp: number[][] = Array.from(new Array(nums.length + 1), () => new Array(capacity + 1).fill(0));
    dp[0][0] = 1;
    for (let i = 1; i <= nums.length; i++) {
        for (let j = 0; j <= capacity; j++) {
            if (j >= nums[i - 1]) {
                dp[i][j] = dp[i - 1][j] + dp[i - 1][j - nums[i - 1]];
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    return dp[nums.length][capacity];
}
```
