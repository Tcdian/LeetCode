## 79. 单词搜索

[<img src="https://static.leetcode-cn.com/cn-mono-assets/production/assets/logo-dark-cn.c42314a8.svg" height="20" /> https://leetcode-cn.com/problems/word-search/](https://leetcode-cn.com/problems/word-search/)

[<img src="https://assets.leetcode.com/static_assets/public/webpack_bundles/images/logo-dark.e99485d9b.svg" height="20"/> https://leetcode.com/problems/word-search/](https://leetcode.com/problems/word-search/)

###

给定一个  `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

#### 示例 1：

<img src="https://assets.leetcode.com/uploads/2020/11/04/word2.jpg" width="322" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
输出：true
```

#### 示例 2：

<img src="https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg" width="322" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "SEE"
输出：true
```

#### 示例 3：

<img src="https://assets.leetcode.com/uploads/2020/10/15/word3.jpg"  width="322" />

```
输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCB"
输出：false
```

#### 提示：

-   `m == board.length`
-   `n = board[i].length`
-   `1 <= m, n <= 6`
-   `1 <= word.length <= 15`
-   `board` 和 `word` 仅由大小写英文字母组成

#### 进阶：

-   你可以使用搜索剪枝的技术来优化解决方案，使其在 board 更大的情况下可以更快解决问题？

#

#### 方法：回溯

```js
/**
 * @param {character[][]} board
 * @param {string} word
 * @return {boolean}
 */
var exist = function (board, word) {
    const direction = [-1, 0, 1, 0, -1];
    const visited = '*';
    for (let i = 0; i < board.length; i++) {
        for (let j = 0; j < board[0].length; j++) {
            if (backtracking(board, [i, j], 0)) {
                return true;
            }
        }
    }
    return false;

    function backtracking(board, [x, y], index) {
        if (board[x][y] === visited || board[x][y] !== word[index]) {
            return false;
        }
        if (index === word.length - 1) {
            return true;
        }
        const current = board[x][y];
        board[x][y] = visited;
        let found = false;
        for (let i = 0; i < 4; i++) {
            const directionX = x + direction[i];
            const directionY = y + direction[i + 1];
            found =
                directionX >= 0 &&
                directionX < board.length &&
                directionY >= 0 &&
                directionY < board[0].length &&
                backtracking(board, [directionX, directionY], index + 1);
            if (found) {
                break;
            }
        }
        board[x][y] = current;
        return found;
    }
};
```
